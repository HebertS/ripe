#!/usr/bin/env ruby

require_relative '../lib/ripe'
require 'thor'

include Ripe

def Task(handle, vars = {})
  $ripe = Controller.new
  filename = $ripe.library.find_task(handle)
  abort "Could not find task #{handle}." if filename == nil
  WorkingBlock.new(filename, vars)
end

class CLI < Thor
  desc 'console', 'Enter ripe console'
  def console
    require 'irb'
    require 'irbtools'

    ARGV.clear # This is necessary because otherwise all arguments
               # get sent to IRB

    $ripe = Controller.new
    $ripe.attach

    IRB.start "ripe #{Ripe::VERSION}"
  end

  desc 'prepare SAMPLES', 'Prepare jobs from template workflow'
  option :workflow, :aliases => '-w', :type => :string, :required => true,
    :desc => 'Workflow to be applied'
  option :options, :aliases => '-o', :type => :string, :required => false,
    :desc => 'Options', :default => ''
  def prepare(*samples)
    abort "No samples specified." if (samples.length == 0)

    additional_vars = options[:options].split(/,/).map do |pair|
      key, value = pair.split(/=/)
      { key.to_sym => value }
    end
    additional_vars = additional_vars.inject(&:merge) || {}

    $ripe = Controller.new

    # Expect $callback to be a lambda function that takes one argument (sample)
    # and returns a Block, and $vars to be a dictionary mapping arguments to
    # values (i.e. resource allocation)
    filename = $ripe.library.find_workflow(options[:workflow])
    abort "Could not find workflow #{options[:workflow]}." if filename == nil
    require_relative filename

    $ripe.attach_or_create # Create .ripe if it doesn't exist
    $ripe.prepare(samples, $callback, $vars.merge(additional_vars))
  end

  desc 'version', 'Retrieve ripe version'
  def version
    puts "ripe version #{Ripe::VERSION}"
  end
end

CLI.start(ARGV)
