#!/usr/bin/env ruby

require_relative '../lib/ripe'
require 'thor'

include Ripe

# Look for workflows and blocks in ./.ripe wherever invoked, then in
# directories specified in the $RIPELIB environment variable.
$RIPELIBS = "#{ENV['PWD']}/.ripe:#{ENV['RIPELIB']}".split(/:/)

def Task(handle, vars = {})
  WorkingBlock.new($RIPELIBS.map{ |path| "#{path}/tasks/#{handle}.sh" }.select{ |path| File.exists? path }.first, vars)
end

class CLI < Thor
  desc 'console', 'Enter ripe console'
  def console
    require 'irb'
    require 'irbtools'

    ARGV.clear # This is necessary because otherwise all arguments
               # get sent to IRB

    $ripe = Controller.new
    $ripe.attach

    IRB.start "ripe #{Ripe::VERSION}"
  end

  desc 'prepare SAMPLES', 'Prepare jobs from template workflow'
  option :workflow, :aliases => '-w', :type => :string, :required => true,
    :desc => 'Workflow to be applied'
  option :options, :aliases => '-o', :type => :string, :required => false,
    :desc => 'Options', :default => ''
  def prepare(*samples)
    return if (samples.length == 0)

    additional_vars = options[:options].split(/,/).map do |pair|
      key, value = pair.split(/=/)
      { key.to_sym => value }
    end
    additional_vars = additional_vars.inject(&:merge) || {}

    # Expect $callback to be a lambda function that takes one argument (sample)
    # and returns a Block, and $vars to be a dictionary mapping arguments to
    # values (i.e. resource allocation)
    workflows = $RIPELIBS.map{ |path| "#{path}/workflows/#{options[:workflow]}.rb" }
    require_relative workflows.select{ |path| File.exists? path }.first

    $ripe = Controller.new
    $ripe.attach_or_create # Create .ripe if it doesn't exist
    $ripe.prepare(samples, $callback, $vars.merge(additional_vars))
  end

  desc 'version', 'Retrieve ripe version'
  def version
    puts "ripe version #{Ripe::VERSION}"
  end
end

CLI.start(ARGV)
